"""Start the Operator Service and serve the offline UI from a single command."""
from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
import threading
import time
import urllib.error
import urllib.request
import webbrowser
from functools import partial
from http.server import SimpleHTTPRequestHandler
from pathlib import Path
from socketserver import TCPServer

from build_ui_bundle import build_ui_bundle, DEFAULT_DIST, DEFAULT_SRC


def _get_env_default(name: str, fallback: str) -> str:
    return os.environ.get(name, fallback)


def _get_env_default_int(name: str, fallback: int) -> int:
    value = os.environ.get(name)
    if value is None:
        return fallback
    try:
        return int(value)
    except ValueError:
        return fallback


def _start_static_server(directory: Path, host: str, port: int) -> TCPServer:
    handler = partial(SimpleHTTPRequestHandler, directory=str(directory))
    httpd = TCPServer((host, port), handler)
    thread = threading.Thread(target=httpd.serve_forever, daemon=True)
    thread.start()
    return httpd


def _start_operator_service(
    host: str, port: int, repo_root: Path, log_path: Path
) -> tuple[subprocess.Popen, object]:
    env = os.environ.copy()
    env["PYTHONPATH"] = f"{repo_root / 'src'}{os.pathsep}{env.get('PYTHONPATH', '')}".rstrip(os.pathsep)

    cmd = [
        sys.executable,
        "-m",
        "operator_service",
        "--host",
        host,
        "--port",
        str(port),
        "--repo-root",
        str(repo_root),
    ]

    log_handle = log_path.open("w", encoding="utf-8")
    proc = subprocess.Popen(cmd, env=env, stdout=log_handle, stderr=subprocess.STDOUT)
    return proc, log_handle


def _write_ui_config(dist: Path, service_url: str, service_host: str, service_port: int) -> None:
    """Write an optional UI config file so the frontend discovers the backend URL."""

    config_path = dist / "operator-config.js"
    payload = {
        "baseUrl": "auto" if service_host in {"0.0.0.0", "127.0.0.1"} else service_url,
        "servicePort": service_port,
        "protocol": "http",
    }
    config_path.write_text(
        "// Generated by run_phase7_local.py to point the UI at the running Operator Service\n"
        f"window.OPERATOR_CONFIG = {json.dumps(payload)};\n",
        encoding="utf-8",
    )


def _await_health(service_url: str, process: subprocess.Popen, timeout: float = 15.0) -> tuple[bool, str]:
    deadline = time.time() + timeout
    last_error = "no response yet"
    url = f"{service_url}/health"
    while time.time() < deadline:
        if process.poll() is not None:
            return False, "Operator Service exited before responding"
        try:
            with urllib.request.urlopen(url, timeout=3) as response:
                if response.status == 200:
                    return True, "ok"
                last_error = f"HTTP {response.status}"
        except urllib.error.URLError as exc:  # noqa: PERF203 - clarity over micro-optimization
            last_error = str(exc.reason) if hasattr(exc, "reason") else str(exc)
        except Exception as exc:  # pragma: no cover - defensive catch
            last_error = str(exc)
        time.sleep(0.5)
    return False, last_error


def _tail_file(path: Path, lines: int = 20) -> str:
    if not path.exists():
        return "(log file not found)"
    content = path.read_text(encoding="utf-8", errors="replace").splitlines()
    if not content:
        return "(log file is empty)"
    tail = content[-lines:]
    return "\n".join(tail)


def parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run Phase 7 offline stack (Operator Service + UI)")
    parser.add_argument(
        "--service-host",
        default=_get_env_default("OPERATOR_SERVICE_HOST", "0.0.0.0"),
        help="Operator Service host (default: 0.0.0.0 or OPERATOR_SERVICE_HOST)",
    )
    parser.add_argument(
        "--service-port",
        type=int,
        default=_get_env_default_int("OPERATOR_SERVICE_PORT", 8000),
        help="Operator Service port (default: 8000 or OPERATOR_SERVICE_PORT)",
    )
    parser.add_argument(
        "--ui-host",
        default=_get_env_default("OPERATOR_UI_HOST", "0.0.0.0"),
        help="UI static server host (default: 0.0.0.0 or OPERATOR_UI_HOST)",
    )
    parser.add_argument(
        "--ui-port",
        type=int,
        default=_get_env_default_int("OPERATOR_UI_PORT", 9000),
        help="UI static server port (default: 9000 or OPERATOR_UI_PORT)",
    )
    parser.add_argument(
        "--no-browser",
        action="store_true",
        default=os.environ.get("OPERATOR_UI_NO_BROWSER") is not None,
        help="Do not automatically open the browser after startup (or set OPERATOR_UI_NO_BROWSER)",
    )
    parser.add_argument(
        "--ui-src",
        type=Path,
        default=Path(_get_env_default("OPERATOR_UI_SRC", str(DEFAULT_SRC))),
        help="Source directory for UI assets (default: ui/ or OPERATOR_UI_SRC)",
    )
    parser.add_argument(
        "--ui-dist",
        type=Path,
        default=Path(_get_env_default("OPERATOR_UI_DIST", str(DEFAULT_DIST))),
        help="Output directory for bundled UI assets (default: dist/operator_ui or OPERATOR_UI_DIST)",
    )
    return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> None:
    args = parse_args(argv)
    repo_root = Path(__file__).resolve().parent.parent

    bundle_path = build_ui_bundle(src=args.ui_src, dist=args.ui_dist)

    service_log = bundle_path / "operator_service.log"

    ui_url = f"http://{args.ui_host}:{args.ui_port}".replace("0.0.0.0", "127.0.0.1")
    service_url = f"http://{args.service_host}:{args.service_port}"

    # Drop a tiny config shim so the UI defaults to the running backend instead of
    # the baked-in localhost:8000. This helps when the service runs on forwarded
    # ports or non-default hosts without asking the user to copy/paste the URL.
    _write_ui_config(bundle_path, service_url, service_host=args.service_host, service_port=args.service_port)

    httpd = _start_static_server(bundle_path, host=args.ui_host, port=args.ui_port)
    service_proc, service_log_handle = _start_operator_service(
        args.service_host, args.service_port, repo_root=repo_root, log_path=service_log
    )

    healthy, detail = _await_health(service_url, service_proc)
    if not healthy:
        print("Operator Service failed to respond on /health.")
        print(f"  URL: {service_url}/health")
        print(f"  Last error: {detail}")
        print(f"  Log: {service_log}")
        print("--- operator_service.log tail ---")
        print(_tail_file(service_log))
        print("--- end log ---")
        httpd.shutdown()
        service_proc.terminate()
        try:
            service_proc.wait(timeout=5)
        except subprocess.TimeoutExpired:
            service_proc.kill()
        service_log_handle.close()
        return

    print("Phase 7 stack is running:")
    print(f"  Operator Service: {service_url}")
    print(f"  Operator UI:      {ui_url}")
    print(f"  Operator Service log: {service_log}")
    print("Press Ctrl+C to stop both servers.")

    if not args.no_browser:
        webbrowser.open(ui_url)

    try:
        service_proc.wait()
    except KeyboardInterrupt:
        pass
    finally:
        httpd.shutdown()
        service_proc.terminate()
        try:
            service_proc.wait(timeout=5)
        except subprocess.TimeoutExpired:
            service_proc.kill()
        service_log_handle.close()


if __name__ == "__main__":
    main()
